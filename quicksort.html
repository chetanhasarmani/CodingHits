<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quick Sort</title>
    <link rel="stylesheet" href="bubble.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="shortcut icon" href="./images/icons8-solidity-80.png" type="image/x-icon">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Josefin+Sans:ital,wght@0,100;0,200;0,300;0,400;0,600;1,200;1,300;1,400;1,500&display=swap" rel="stylesheet">

</head>
<body>
    <div class="container overflow-x-hidden ">
        <div class="subwrapper" >

            <h1 class="heading mt-10 text-5xl font-medium ">Quick Sort</h1>
            <p class="mt-14 text-lg font-light leading-7 tracking-wider mb-14  ">Quick Sort Algorithm work on the Principal of Divide and Conquer. It picks an element as pivot and partitions the given array around the picked pivot. There are many different versions of quickSort that pick pivot in different ways.</p>
            <img src="./images/quicksort.gif" width="100%" height="30%"  alt="">
            <p class="mt-8 text-2xl mb-5">Quick Sort Implementation</p>

            <div class="flex justify-between mt-20 mb-9 w-[90%]   "> 
                    <p class="capitalize text-6xl font-thin  py-5   " >The <br> Syntax <br> For Quick <br> Sort In Javascript</p>
                    <pre class="text-sm text-white   ">  
                        function quickSortIterative(arr) {
                            // Creating an array that we'll use as a stack, using the push() and pop() functions
                            stack = [];
                            
                            // Adding the entire initial array as an "unsorted subarray"
                            stack.push(0);
                            stack.push(arr.length - 1);
                            
                            // There isn't an explicit peek() function
                            // The loop repeats as long as we have unsorted subarrays
                            while(stack[stack.length - 1] >= 0){
                                
                                // Extracting the top unsorted subarray
                                end = stack.pop();
                                start = stack.pop();
                                
                                pivotIndex = partition(arr, start, end);
                                
                                // If there are unsorted elements to the "left" of the pivot,
                                // we add that subarray to the stack so we can sort it later
                                if (pivotIndex - 1 > start){
                                    stack.push(start);
                                    stack.push(pivotIndex - 1);
                                }
                                
                                // If there are unsorted elements to the "right" of the pivot,
                                // we add that subarray to the stack so we can sort it later
                                if (pivotIndex + 1 &lt;  end){
                                    stack.push(pivotIndex + 1);
                                    stack.push(end);
                                }
                            }
                        }
                
                    </pre>

            </div>

            <div class="w-[90%] h-[1px] mx-auto  bg-[#DEB992] "></div>

            <div class="flex justify-between mt-20 w-[90%]  "> 
                <p class="capitalize text-6xl  font-thin  pb-10 " >The <br> Quick <br> Sort <br> Algorithm <br> Analysis</p>
                <pre class="text-lg text-white   ">  
                    Best Case: O(nlogn) 
                    Average Case: O(nlogn)
                    Worst Case: O(n^2)
                    Space Complecity: O(logn)
                    Quick Short Algorithm are Internal Shorting Algorithm
                    Quick Short Algorithm are Recursive Shorting Algorithm
                    Stability: No Quick Short Algorithm Are Not Stable Algorithm
                    Adpative: Yes Quick Short Algorithm Are Adpative Algorithm
                </pre>

        </div>   

        </div>

    </div>
    
</body>
</html>
